\chapter{DENEY} \label{chap:experimentation}

\section{Yöntem}

Dinamik Papoulish-Gerchberg algoritmasının SLAM'e katkısını ölçülebilir kılmak için bu tez kapsamında oluşturulan SensorSuiteV2 ve benzer veri tiplerini içeren açık kaynak CitrusFarm versiseti kullanılmıştır. Bu verisetlerindeki veriler RTABMap aracı kullanılarak doğrudan veya algoritmayla ön işlemeden geçirilerek işlenmiştir.

Algoritma katkısının hangi algoritma adımlarıca majör olarak sağlandığını bulabilmek için deneyler superposition prensibine uygun olarak decompose edilmiştir. Ön işleme (PG algoritması) farklı adımları bypass geçilerek geriye kalan kısımlarının iyileşmeye katkısı değerlendirilmiştir. En sonunda kümülatif katkının süperpozisyon prensipine uygun olup olmadığı değerlendirilmiştir.

Deney esnasında decompose edilen parçalar şu şekildedir:

\begin{itemize}
    \item Bütünleşik algoritmanın çıktısı derinlik imajı
    \item PG iterason sayısını N adet discrete değer ile üretilen derinlik imajı (N çeşitlendirerek iyileşme lineerlinin test edilmesi amaçlanmıştır N=[0, 33])
    \item Lidar upsampleda kullanilan geriye dönük lidar frame sayısının çeşitlendirilmesi algoritma çıktısı derinlik imajı N[1,10]
\end{itemize}

Tüm bu deney çıktılarının SLAM performanlarının karşılaştırılması için odometri çıktıları birleştirilerek elde edilen güzergahlar RTK GPS verisi ile karşılaştırılmıştır.

Kendi verisetimizde loop-closure içeren kısımları da barındırdığımız için path örtüşmesi kıyasının yanı sıra aynı pozisyondan geçerkenki drift değerleri de kıyaslanmıştır.

SLAM çıktısının bir diğeri üç boyutlu harita olduğu için aynı zamanda üç boyutlu harita performansları da kıyaslanmıştır. Burada temel ölçü olarak harita çözünürlüğü, harita alignment hatası ve bir de gözle yapılan kıyasların görsellerine tez kapsamında yer verilmiştir.Bahsedilen son metrik öznel yargılar işerebileceği gibi ektra eklendiği için bilimsel bir kanıt amacı günülmemiş, yalnızca bir bakış açısı katılması amaçlanmıştır.

Deneyde yalnızca Lidar ve IMU tabanlı SLAM algoritmaları ile karşılaştırmaya girilmemiştir. Bunun temel sebebi Lidarın seyrek veri yapısının renksiz ve düşük çözünürlüklü SLAM çıktısının stereo depth ile elde edilen SLAM çıktısıyla karşılaştırılmasının çok fazla metrik değişiminden dolayı sağlıksız olmasıdır.

\subsection{Bütünleşik algoritma parametreleri ve akışı}

Algoritma baştan uca tüm parametrelerin en iyi sonucu vereceği tahmin edilen dahiliyle deneye sokulmuştur.

Bu başlık altında test edilen şeyin ne tür bir füsyon olduğu görsellerle anlatılmalıdır.

\subsection{Değişken PG iterasyon sayısı}

Bu başlık altında test edilen şeyin ne tür bir füsyon olduğu görsellerle anlatılmalıdır.

\subsection{Değişken Lidar upsample Lidar History sayısı}

Bu başlık altında test edilen şeyin ne tür bir füsyon olduğu görsellerle anlatılmalıdır.

Alt başlıklarda verilen deney yöntemleri tek bir tablo altına toplanmış ve matris yapı ile çaprazlanarak deneyler tamamlanmıştır.
Bu deneylerin sonuçları grafikler ve tablolar ile nicel olarak ele alınmalıdır.
APE ve benzeri yöntemler ile ilgili numerik çıktılar buraya eklenmelidir.
XYZ güzergah karşılaştırmaları eklenmelidir.

\input{./MainSections/16.1_MathematicalExperimentationMethodology}
%\input{./MainSections/16.1_MathematicalExperimentationMethodology_EN}

\subsection{Trajektori Hizalama ve Kabsch Algoritması}
\label{sec:kabsch_alignment}

Bu çalışmada, farklı sensör kaynaklarından elde edilen trajektori tahminlerinin karşılaştırılabilmesi amacıyla, ölçüm sonuçları öncelikle ortak bir referans çerçevesine hizalanmıştır. Bu hizalama işlemi, \textit{evo}\cite{grupp2017evo} değerlendirme aracı tarafından kullanılan ve literatürde yaygın olarak kabul gören \textbf{Kabsch algoritması}\cite{Kabsch:a12999} temel alınarak gerçekleştirilmiştir.

Kabsch algoritması, iki eşleşmiş nokta kümesi arasındaki \textit{ortalama kare hatayı} (Root Mean Squared Deviation -- RMSD) minimize eden en uygun rijit dönüşümü (rotasyon ve öteleme) hesaplamayı amaçlar. Bu bağlamda, referans trajektori
$P = \{\mathbf{p}_i\}_{i=1}^N$
ve tahmin edilen trajektori
$Q = \{\mathbf{q}_i\}_{i=1}^N$
olmak üzere, her iki kümede yer alan noktaların zamansal olarak eşleştiği varsayılır.

Algoritmanın ilk adımında, her iki nokta kümesinin ağırlık merkezleri hesaplanarak merkezlenmiş noktalar elde edilir:
\[
\mathbf{p}'_i = \mathbf{p}_i - \bar{\mathbf{p}}, \quad
\mathbf{q}'_i = \mathbf{q}_i - \bar{\mathbf{q}}.
\]

Ardından, merkezlenmiş noktalar kullanılarak kovaryans matrisi tanımlanır:
\[
\mathbf{H} = \sum_{i=1}^{N} \mathbf{p}'_i \mathbf{q}'_i{}^{\top}.
\]

Bu matrisin tekil değer ayrışımı (Singular Value Decomposition -- SVD) şu şekilde ifade edilir:
\[
\mathbf{H} = \mathbf{U}\,\boldsymbol{\Sigma}\,\mathbf{V}^{\top}.
\]

Optimal rotasyon matrisi, yansıma durumlarını önleyecek biçimde
\[
\mathbf{R} =
\mathbf{V}
\begin{pmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & \det(\mathbf{V}\mathbf{U}^{\top})
\end{pmatrix}
\mathbf{U}^{\top}
\]
olarak hesaplanır. Öteleme vektörü ise
\[
\mathbf{t} = \bar{\mathbf{p}} - \mathbf{R}\,\bar{\mathbf{q}}
\]
şeklinde elde edilir.

Bu dönüşüm sayesinde, tahmin edilen trajektori referans trajektoriye en iyi şekilde hizalanır ve iki yol arasındaki farklar, global konum ve yönelim farklarından arındırılmış olarak değerlendirilir. Bu çalışmada sunulan hizalanmış trajektori hata metrikleri (örneğin Absolute Pose Error -- APE ve Relative Pose Error -- RPE), hizalanmış trajektoriler üzerinden \textit{evo} aracı kullanılarak hesaplanmıştır. Böylece elde edilen sonuçlar, sistemin gerçek izleme doğruluğunu yansıtan anlamlı karşılaştırmalar sunmaktadır.

\section{CitrusFarm Veriseti}

Bu başlık altında Deney senaryolarında bahsi geçen deneyler CitrusFarm veriseti ile gerçeklenmiştir. Deney sonuçları yine deneyler başlığında bahsedildiği şeklinde sergilenmiştir.

Deney sonuçlarındaki bir yöne doğru yünelimin esas sebebi tekerlek odometrisi versindeki biased durumdur. Bunun grafiği eklenmeli. Sürekli bir sola dönüş gösterilmiş. Daha sonra da yaw düzeltmesi ele alınabilir.

\input{./Experiments/Results}
\input{./Experiments/CitrusFarmResults_EN}

\section{SensorSuiteV2 Veriseti}

Bu başlık altında Deney senaryolarında bahsi geçen deneyler SensorSuite veriseti ile gerçeklenmiştir. Deney sonuçları yine deneyler başlığında bahsedildiği şeklinde sergilenmiştir.

\section{Paralel İşleme Performansı}

GPU ile sinyal işlemeye dayalı yöntemler geliştirildiği için çeşitli GPU modelleri ile deneyler tekrarlandı. PG algoritması başarımının iterasyon sayısı ile doğru orantılı olduğu ve işlem gücü dar boğazının asıl PG iterasyon sayılarından meydana geldiği göz önünde bulundurularak bağımsız değişkenin GPU çeşiti ve bağımlı değişkenin 100 mili saniyedeki maksimum PG iterasyon sayısı oldu bir deney yapıldı. Deney sonucunda NVidia GPU'lardaki Cuda çekirdek sayıları ile maksimum PG iterasyonu sayısı arasında Şekil~\ref{fig:cuda_core_vs_pg_iter}'de verilen sayısal sonuçlara ulaşıldı.

\begin{figure}[H]
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[height=7cm]{./Figures/pg_filter_selection/dama_brick-wall_0.64_2000.png}
        \caption{Karşılaştırma eğrisi}
        \label{fig:cuda_core_vs_pg_iter_chart}
    \end{subfigure}

    \vspace{0.8em}

    % ---------- Row 3 ----------
    \begin{subfigure}[t]{0.48\textwidth}
        \centering

        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{lcc}
            \toprule
            \textbf{GPU}           & \textbf{Cuda Çekirdeği Sayısı} & \textbf{Max PG İterasyon Sayısı} \\
            \midrule
            Nvidia Jatson Orin NX? & ?                              & 10?                              \\
            RTX2060                & ?                              & 33                               \\
            T4000?                 & ?                              & 50?                              \\
            A4000?                 & ?                              & 100                              \\
            \bottomrule
        \end{tabular}

        \caption{Nümerik karşılaştırma}
        \label{fig:cuda_core_vs_pg_iter_table}
    \end{subfigure}

    \caption{NVidia GPU ve PG iterasyon sayısı karşılaştırması}
    \label{fig:cuda_core_vs_pg_iter}
\end{figure}

Algoritmanın emekleme ve ilk adım safhaları değerlendirilmdiğinde bu değerler oldukça yüksek başarıyı ifade etmektedir. 3B point cloud verisinde yaptığımız ilk PG iterasyonu (tek iterasyon) CPU üzerinde paralel işleme olmaksızın 50 saniyede (50 s) tamamlanırken gelinen son noktada bir iterasyon tüm GPU çetileri göz çnüne alındığında milisaniyenin onda biri (0.1 ms) mertebelerine düşürülmüştür.

Önerdiğimiz yöntemin gerçek zamanlı çalıştırılabilmesi için ekstra efor harcanmış ve başarılı olunmuştur.
